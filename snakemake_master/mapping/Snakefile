''' VARIABLES '''
# USER defined variables (in theory do not need to be touched)
spls = "samples.csv"

import sys
SCRIPTS_DIRECTORY = "/scratch/mit_lieberman/scripts"
sys.path.insert(0, SCRIPTS_DIRECTORY)

from read_samplesCSV import read_samplesCSV
from read_move_link_samplesCSV import *

''' PRE-SNAKEMAKE '''
## define couple of lists from samples.csv
## Format: Path,Sample,ReferenceGenome,ProviderName,Subject
[PATH_ls, SAMPLE_ls, REF_Genome_ls, PROVIDER_ls, PATIENTID_ls] = read_samplesCSV(spls)


''' SNAKEMAKE '''
rule all:
    input:
        expand("data/{sampleID}/R1.fq.gz",sampleID=SAMPLE_ls),
        expand("6-diversity/{sampleID}_ref_{references}_aligned.sorted.strain.variant.diversity.mat", zip, sampleID=SAMPLE_ls, references=REF_Genome_ls),
        expand("/scratch/mit_lieberman/reference_genomes/{references}/genome_bowtie2.1.bt2",references=set(REF_Genome_ls)),
        expand("5-quals/{sampleID}_ref_{references}_aligned.sorted.strain.variant.quals.mat", zip, sampleID=SAMPLE_ls, references=REF_Genome_ls),
        "logs/DONE_cleanUp",
        
rule make_data_links:
	# NOTE: All raw data needs to be names fastq.gz. No fq! The links will be names fq though.
	output:
		fq1=expand("data/{sampleID}/R1.fq.gz",sampleID=SAMPLE_ls),
		fq2=expand("data/{sampleID}/R2.fq.gz",sampleID=SAMPLE_ls),
	run:
		for i, path in enumerate(PATH_ls):
			if not(os.path.isfile(SAMPLE_ls[i])):
				os.makedirs('data/' + SAMPLE_ls[i], exist_ok=True)
			paths = path.split(' ')
			if len(paths)>1:
				cp_append_files(paths, SAMPLE_ls[i], PROVIDER_ls[i])
			else:
				makelink(path, SAMPLE_ls[i], PROVIDER_ls[i])

rule cutadapt:
	input:
		# Recommend using symbolic links to your likely many different input files
		fq1="data/{sampleID}/R1.fq.gz",
		fq2="data/{sampleID}/R2.fq.gz",
	output:
		fq1o="1-cutadapt_temp/{sampleID}_R1_trim.fq.gz",
		fq2o="1-cutadapt_temp/{sampleID}_R2_trim.fq.gz",
	log:
		log1="logs/cutadapt_{sampleID}_R1.txt",
		log2="logs/cutadapt_{sampleID}_R2.txt",
	shell:
		# need to load py2.7 module.
		"module add c3ddb/python/2.7.11 ;"
		"python2.7 ~/.local/lib/python2.7/site-packages/cutadapt -a CTGTCTCTTAT -o {output.fq1o} {input.fq1} > {log.log1} 2>&1 ;"
		"python2.7 ~/.local/lib/python2.7/site-packages/cutadapt -a CTGTCTCTTAT -o {output.fq2o} {input.fq2} > {log.log1} 2>&1 ;"

rule sickle2050:
	input:
		fq1="1-cutadapt_temp/{sampleID}_R1_trim.fq.gz",
		fq2="1-cutadapt_temp/{sampleID}_R2_trim.fq.gz",
	output:
		fq1o="2-sickle2050_temp/{sampleID}_filt1.fq",
		fq2o="2-sickle2050_temp/{sampleID}_filt2.fq",
		fqSo="2-sickle2050_temp/{sampleID}_filt_sgls.fq",
	log:
		log="logs/sickle_{sampleID}.txt",
	shell:
		"module add c3ddb/sickle/1.33 ;"
		"sickle pe -f {input.fq1} -r {input.fq2} -t sanger -o {output.fq1o} -p {output.fq2o} -s {output.fqSo} -q 20 -l 50 -x -n > {log} 2>&1 "


rule refGenome_index:
	input:
		"/scratch/mit_lieberman/reference_genomes/{references}/genome.fasta"
	params:
		"/scratch/mit_lieberman/reference_genomes/{references}/genome_bowtie2",
	log:
		log="logs/refgenome_index_{references}.txt",
	output:
		"/scratch/mit_lieberman/reference_genomes/{references}/genome_bowtie2.1.bt2"
	shell:
		"module add c3ddb/bowtie2/2.2.6 ;"
		" bowtie2-build -q {input} {params} "


rule bowtie2:
	input:
		fq1="2-sickle2050_temp/{sampleID}_filt1.fq",
		fq2="2-sickle2050_temp/{sampleID}_filt2.fq",
		bowtie2idx="/scratch/mit_lieberman/reference_genomes/{references}/genome_bowtie2.1.bt2" # put here, so rule botie2 only executed after rule refGenome_index done
	params:
		refGenome="/scratch/mit_lieberman/reference_genomes/{references}/genome_bowtie2",
		fqU="3-bowtie2/{sampleID}_ref_{references}_unaligned.fastq", # just a prefix. 
	output:
		samA="3-bowtie2/{sampleID}_ref_{references}_aligned.sam",
	log:
		log="logs/bowtie2_{sampleID}_ref_{references}.txt",
	shell:
		# 8 threads coded into json
		"module add c3ddb/bowtie2/2.2.6 ;"
		"bowtie2 --threads 8 -X 2000 --no-mixed --dovetail --un-conc {params.fqU} -x {params.refGenome} -1 {input.fq1} -2 {input.fq2} -S {output.samA} > {log} 2>&1 "

rule sam2bam_cleanUp:
	input:
		samA="3-bowtie2/{sampleID}_ref_{references}_aligned.sam",
	params:
		fqU1="3-bowtie2/{sampleID}_ref_{references}_unaligned.1.fastq",
		fqU2="3-bowtie2/{sampleID}_ref_{references}_unaligned.2.fastq",
	output:
		bamA="3-bowtie2/{sampleID}_ref_{references}_aligned.sorted.bam",
	log:
		log="logs/sam2bam_cleanUp_{sampleID}_ref_{references}.txt",
	shell:
		# 8 threads coded into json
		"module add c3ddb/samtools/1.5 ;"
		" samtools view -bS {input.samA} | samtools sort - -o {output.bamA} > {log} 2>&1 ; "
		" samtools index {output.bamA} ;"
		" bgzip -f {params.fqU1}; bgzip -f {params.fqU2}; rm {input.samA} ;"

rule mpileup2vcf:
	input:
		bamA="3-bowtie2/{sampleID}_ref_{references}_aligned.sorted.bam",
		ref="/scratch/mit_lieberman/reference_genomes/{references}/genome.fasta"
	output:
		pileup="4-vcf/{sampleID}_ref_{references}_aligned.sorted.pileup",
		variants="4-vcf/{sampleID}_ref_{references}_aligned.sorted.strain.variant.vcf.gz",
		vcf_strain="4-vcf/{sampleID}_ref_{references}_aligned.sorted.strain.vcf.gz",
	params:
		vcf_raw="4-vcf/{sampleID}_ref_{references}_aligned.sorted.strain.gz",
	log:
		"logs/mpileup2vcf_{sampleID}_ref_{references}.txt",
	shell:
		" module add c3ddb/samtools/1.5 ; module add c3ddb/bcftools/1.2 ;"
		" samtools faidx {input.ref} ; "
		" samtools mpileup -q30 -x -s -O -d3000 -f {input.ref} {input.bamA} > {output.pileup} 2> {log} ;" 
		" samtools mpileup -q30 -t SP -d3000 -vf {input.ref} {input.bamA} > {params.vcf_raw} 2>> {log} ; "
		" bcftools call -c -Oz -o {output.vcf_strain} {params.vcf_raw} 2>> {log} ; "
		" bcftools view -Oz -v snps -q .75 {output.vcf_strain} > {output.variants} 2>> {log} ; "
		" tabix -p vcf {output.variants} ;"
		" rm {params.vcf_raw}"

# strain.vcf ==> vcf_to_quals.m ==> quals.mat
rule vcf2quals:
	input:
		vcf_strain = "4-vcf/{sampleID}_ref_{references}_aligned.sorted.strain.vcf.gz",
	params:
		refGenomeDir="/scratch/mit_lieberman/reference_genomes/{references}/"
	log:
		"logs/vcf2quals_{sampleID}_ref_{references}.txt",
	output:
		file_quals = "5-quals/{sampleID}_ref_{references}_aligned.sorted.strain.variant.quals.mat", 
	shell:
		"""
		module add mit/matlab/2015b; 
		matlab -r "path('{SCRIPTS_DIRECTORY}',path); vcf_to_quals_snakemake( '{input.vcf_strain}', '{output.file_quals}', '{params.refGenomeDir}' )" > {log} 2>%1
		"""

# strain.pileup ==> pileup_to_diversity.m ==> diversity.mat
rule pileup2diversity_matrix:
	input:
		pileup = "4-vcf/{sampleID}_ref_{references}_aligned.sorted.pileup",
	params:
		refGenomeDir="/scratch/mit_lieberman/reference_genomes/{references}/",	
	log:
		"logs/pileup2diversity_matrix_{sampleID}_ref_{references}.txt",
	output:
		file_diversity = "6-diversity/{sampleID}_ref_{references}_aligned.sorted.strain.variant.diversity.mat",
		file_coverage = "6-diversity/{sampleID}_ref_{references}_aligned.sorted.strain.variant.coverage.mat",
	shell:
		"""
		module add mit/matlab/2015b; 
		matlab -r "path('{SCRIPTS_DIRECTORY}',path); pileup_to_diversity_matrix_snakemake( '{input.pileup}', '{output.file_diversity}', '{output.file_coverage}', '{params.refGenomeDir}' )" ;
		rm {input.pileup};
		"""

rule cleanUp:
	input:
		part1 = expand("5-quals/{sampleID}_ref_{references}_aligned.sorted.strain.variant.quals.mat", zip, sampleID=SAMPLE_ls, references=REF_Genome_ls),  # input not used, only required so snakemake waits with clean up until the end
		part2 = expand("6-diversity/{sampleID}_ref_{references}_aligned.sorted.strain.variant.diversity.mat", zip, sampleID=SAMPLE_ls, references=REF_Genome_ls),  # input not used, only required so snakemake waits with clean up until the end
	params:
		cutad="1-cutadapt_temp/",
		sickle="2-sickle2050_temp/",
	output:
		"logs/DONE_cleanUp",
	shell:
		" rm -fr {params.cutad} {params.sickle} ;"
		" touch {output} ;"




